### 面试大纲

#### Java集合

##### HashMap和Hashtable区别

* 父类不同: HashMap的父类AbstractMap,而HashTable是继承自Dictionary;
* null值问题: HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。Hashtable既不支持Null key也不支持Null value;
* 线程安全性: Hashtable是线程安全的;HashMap不是线程安全的，在多线程并发的环境下，可能会产生死锁等问题。

##### ArrayList和Vector的区别

* **相同点**
  * 两个类都实现了List接口(List接口继承了Collection)且都是有序集合;
  * 可以按位置索引号取出某个元素,且其中的数据是允许重复;这是与HashSet之类的集合的最大不同处,HashSet之类的集合不可以按索引号去检索其中的元素,也不允许有重复的元素;
* **不同点**
  * 线程安全: Vector是线程安全的,ArrayList是线程不安全的;
  * 数据增长: Vector增长原来的一倍,ArrayList增加原来的0.5倍;

#### 快速失败(fail-fast)和安全失败(fail-safe)的区别

> **快速失败**
>
> 在使用迭代器对集合对象进行遍历的时候，如果A线程对集合进行遍历，正好B线程对集合进行修改（增加、删除、修改）则A线程会抛出ConcurrentModificationException异常。
>
> 原理是：
>
> 迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
>
> 场景：
>
> java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）
>
> **安全失败**
>
>  采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
>
>  由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception，例如CopyOnWriteArrayList。
>
> 缺点：
>
> ​    基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
>
> 场景：
>
>  java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。
>
> 快速失败和安全失败是对迭代器而言的。
>
>  快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 
>
> 安全失败：在迭代时候会在集合底层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败
> 

#### JVM

#### 多线程

#### 中间件

##### Redis

##### Kafka

##### Elasticsearch

#### 数据库

#### Spring

#### 设计模式



