### Redis 面试题

#### Redis雪崩问题

* 描述

  >**现象**：大量key同一时间点失效，同时又有大量请求打进来，导致流量直接打在DB上，造成DB不可用。

* **解决方案**：

  - 设置key永不失效（热点数据）；
  - 设置key缓存失效时候尽可能错开(把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。)；
  - 使用多级缓存机制，比如同时使用redsi和memcache缓存，请求->redis->memcache->db；
  - 购买第三方可靠性高的Redis云服务器；

#### 缓存穿透问题

* **描述**

  > **现象**：用户大量并发请求的数据(key)对应的数据在redis和数据库中都不存在，导致尽管数据不存在但还是每次都会进行查DB。
  >
  > 为什么key对应数据在缓存和db中不存在还会每次都进行DB查询呢？因为很多开发同学写的代码写的逻辑都是先从redis缓存中查一把，如果缓存中为空则从DB中查，如果DB中查到的数据不为空则设置到缓存并返回给接口。那么问题来了，如果从DB中查询的数据为空呢？？

* **解决方案**：

  - 从DB中查询出来数据为空，也进行空数据的缓存，缓存时间设置短一点,或者该key对应的数据存在之后进行清理缓存,避免DB数据为空也每次都进行数据库查询；

  - 对一定不存在的key,进行过滤

  - 可以将所有可以能存在的key放到一个大的Bitmap中,查询时通过该Bitmap过滤,或者使用布隆过滤器，但是会增加一定的复杂度及存在一定的误判率；
  
    ```xml
    <dependencies>  
         <dependency>  
             <groupId>com.google.guava</groupId>  
             <artifactId>guava</artifactId>  
             <version>23.0</version>  
         </dependency>  
  </dependencies>  
    ```

#### Redis的淘汰删除策略

* Redis中通过`maxmemory`参数来设定内存的使用上限,如果Redis锁使用内存超过设定的最大值,那么会更根据配置文件中的策略选取要删除的key来删除,从而留出新的键值空间;在配置文件redis.conf 中，可以通过参数 `maxmemory <bytes>` 来设定最大内存：

* 主要有六种内存淘汰key方式
  * `volatile-lru`:  利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 。
  * `allkeys-lru`:利用LRU算法移除任何key （和上一个相比，删除的key包括设置过期时间和不设置过期时间的）。**通常使用该方式**。
  * `volatile-random`:移除设置过过期时间的随机key 。
  * `allkeys-random`: 随机移除一个key;
  * `volatile-ttl `:移除即将过期的key(minor TTL) 
  * `noeviction`: 当内存使用达到阀值的时候满所有引起申请内存的命令会报错;

* Redis过期时间判定

  > 　在Redis内部，每当我们设置一个键的过期时间时，Redis就会将该键带上过期时间存放到一个**过期字典**中。当我们查询一个键时，Redis便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。

* 过期删除策略

  * 定时删除

    > 　　在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。
    >
    > 　　优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。
    >
    > 　　缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。

  * 惰性删除

    > 　　设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。
    >
    > 　　优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。
    >
    > 　　缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。

  * 定期删除

    > 　　每隔一段时间，我们就对一些key进行检查，删除里面过期的key。
    >
    > 　　优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。
    >
    > 　　缺点：难以确定删除操作执行的时长和频率。
    >
    > 　　　　　如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。
    >
    > 　　　　　如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。
    >
    > 　　　　　另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。

* Redis过期删除策略

  > Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。
  >
  > 　　**惰性删除**：Redis的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。
  >
  > 　　**定期删除**：由redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
  >
  > 　　注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。
  >
  > 　　定期删除函数的运行频率，在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 **hz** 选项来调整这个次数





  

  