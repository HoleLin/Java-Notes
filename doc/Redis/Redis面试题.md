### Redis 面试题

* **参考文献**
  * [分布式系统架构面试题汇总（万字总结）](https://zhuanlan.zhihu.com/p/267712773)

#### Redis雪崩问题

* **描述**

  >**现象**：大量key同一时间点失效，同时又有大量请求打进来，导致流量直接打在DB上，造成DB不可用。

* **解决方案**：

  - 设置key永不失效（热点数据）；
  - 设置key缓存失效时候尽可能错开(把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。)；
  - 使用多级缓存机制，比如同时使用redsi和memcache缓存，请求->redis->memcache->db；

#### 缓存穿透问题

* **描述**

  > **现象**：用户大量并发请求的数据(key)对应的数据在redis和数据库中都不存在，导致尽管数据不存在但还是每次都会进行查DB。
  >
  > 为什么key对应数据在缓存和db中不存在还会每次都进行DB查询呢？因为很多开发同学写的代码写的逻辑都是先从redis缓存中查一把，如果缓存中为空则从DB中查，如果DB中查到的数据不为空则设置到缓存并返回给接口。那么问题来了，如果从DB中查询的数据为空呢？？

* **解决方案**：

  - 从DB中查询出来数据为空，也进行空数据的缓存，缓存时间设置短一点,或者该key对应的数据存在之后进行清理缓存,避免DB数据为空也每次都进行数据库查询；**缓存空对象**

  - 对一定不存在的key,进行过滤

  - 可以将所有可以能存在的key放到一个大的Bitmap中,查询时通过Bitmap过滤,或者使用**布隆过滤器**(Bloom Filter)，但是会增加一定的复杂度及存在一定的误判率；
  
    ```xml
    <dependencies>  
         <dependency>  
             <groupId>com.google.guava</groupId>  
             <artifactId>guava</artifactId>  
             <version>23.0</version>  
         </dependency>  
  </dependencies>  
    ```

#### 缓存击穿

* **描述**

  > 缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。

* **解决方案**

  > 在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接击中缓存，防止了缓存击穿。

#### Redis的淘汰删除策略

* Redis中通过`maxmemory`参数来设定内存的使用上限,如果Redis锁使用内存超过设定的最大值,那么会更根据配置文件中的策略选取要删除的key来删除,从而留出新的键值空间;在配置文件redis.conf 中，可以通过参数 `maxmemory <bytes>` 来设定最大内存：

* **主要有六种内存淘汰key方式**
  
  * `volatile-lru`:  利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 。
  * `allkeys-lru`:利用LRU算法移除任何key （和上一个相比，删除的key包括设置过期时间和不设置过期时间的）。**通常使用该方式**。
  * `volatile-random`:移除设置过过期时间的随机key 。
  * `allkeys-random`: 随机移除一个key;
  * `volatile-ttl `:移除即将过期的key(minor TTL) 
* `noeviction`: 当内存使用达到阀值的时候满所有引起申请内存的命令会报错;
  
* **Redis过期时间判定**

  > 　在Redis内部，每当我们设置一个键的过期时间时，Redis就会将该键带上过期时间存放到一个**过期字典**中。当我们查询一个键时，Redis便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。

* **过期删除策略**

  * **定时删除**

    > 　　在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。
    >
    > 　　优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。
    >
    > 　　缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。

  * **惰性删除**

    > 　　设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。
    >
    > 　　优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。
    >
    > 　　缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。

  * **定期删除**

    > 　　每隔一段时间，我们就对一些key进行检查，删除里面过期的key。
    >
    > 　　优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。
    >
    > 　　缺点：难以确定删除操作执行的时长和频率。
    >
    > 　　　　　如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。
    >
    > 　　　　　如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。
    >
    > 　　　　　另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。

* **Redis过期删除策略**

  > Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。
  >
  > 　　**惰性删除**：Redis的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。
  >
  > 　　**定期删除**：由redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。
  >
  > 　　注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。
  >
  > 　　定期删除函数的运行频率，在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 **hz** 选项来调整这个次数

#### Redis 哨兵模式原理

* **哨兵如何实现相互监督的功能**
  * 第一: 哨兵通过发布订阅\_sentinel_:hello channel来实现这个功能.每个哨兵每隔2s会想自己监控的所有主从Redis节点发送hello message,包括自己的IP,端口,运行ID,自己监控的Master节点IP,Master节点端口;
  * 第二: 所有主从Redis节点也会反馈这样的信息;

* **哨兵如何检测故障**

  * 第一: 某个哨兵节点判定Master节点故障,它会投出一票S_DOWN
  * 第二: 当有足够多的sentinel节点判定Master节点故障都投出S_DOWN票时,Master节点会被认为真正的下线了
  * 也就是**基于多数投票原则**

* **哨兵模式如何实现故障恢复**

  * 故障恢复需要完成如下几步操作:
    * 第一: 通过选主机制选择新的Master节点替换掉原来的故障节点;
    * 第二: 其他的节点称为Slave节点用于主从复制,也就是身份保持不变;
    * 第三: 告知客户端新的Master节点地址信息,同时执行必要的脚本来通知系统管理员;

* **选主机制**

  * **过程**

    > sentinel的选举过程基本上是Raft协议的实现，即所有节点会随机休眠一段时间，然后发起拉票，当某个节点获得的票数超过max(sentinel|/2 + 1), qurom时，该节点就被推选为leader节点。注意是哨兵去从节点里面选。

  * **选谁**

    > **①根据指定的优先级选择**
    >
    > 管理员在启动redis从节点的时候，指定了其优先级，哨兵会先从优先级高的从节点去选择。
    >
    > ②**根据数据更新程度选择**
    >
    > 优先级相同，所有slave节点复制数据的时候都会记录复制偏移量，值越大说明与master节点的数据更一致。所以哨兵会选择复制偏移量最大的节点。
    >
    > ③**根据runid选择：**
    >
    > 到了这一步节点的孰优孰劣就没什么区别了，每个节点启动的时候都会有一个唯一的runId, 那么我们就选择runid最小的节点好了。

#### **Redis缓存与数据库数据一致性**

* **描述**

  > 不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：
  >
  > 1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
  >
  > 2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。
  >
  > 怎么保证缓存一致性？：读直接去缓存读，没有的话就读数据库，写直接写数据库，然后失效缓存中对应的数据

* **解决方案**

  * **第一种方案：延时双删策略+缓存超时设置**

    * 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。

    * **具体步骤**

      > 1）先删除缓存；
      >
      > 2）再写数据库；
      >
      > 3）休眠一段时间；
      >
      > 4）再次删除缓存。
      >
      > **设置缓存过期时间**
      >
      > 所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。也就是看到写请求就执行上面的策略。

  * **第二种方案：异步更新缓存(基于订阅binlog的同步机制)**

    * MySQL binlog增量订阅消费+消息队列+增量数据更新到redis
    * 一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息通过消息队列推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。

#### Redis的热key问题如何解决

* **理论**

  > 所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。

* **发现热key**

  > 方法一:凭借业务经验，进行预估哪些是热key 其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。
  >
  > 方法二:在客户端进行收集 这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。
  >
  > 方法三:在Proxy层做收集 有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。
  >
  > **方法四:用Redis自带命令**
  >
  > (1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。
  >
  > (2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。
  >
  > **方法五:自己抓包评估**
  >
  > Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。

* **解决方案**

  > (1) 利用二级缓存 比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。
  >
  > 针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。
  >
  > 现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。
  >
  > (2) 备份热key 这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。

#### Redis主从复制

* 理论

  * 在Redis客户端通过`info replicaton`可以查看与复制相关的状态,对于了解主从节点的当前状态,以及解决出现的问题都会有帮助.

  > 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。
  >
  > 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

* **主从复制的作用:**

  * **数据冗余**：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
  * **故障恢复**：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
  * **负载均衡**：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
  * **高可用基石**：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

