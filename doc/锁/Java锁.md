### 锁

#### 参考文献

* [不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)

#### Java锁分类

* 线程要不要锁住同步资源?
  * 锁住
    * 悲观锁
  * 不锁住
    * 乐观锁
* 锁住同步资源失败,线程要不要阻塞?
  * 阻塞
  * 不阻塞
    * 自旋锁
    * 适应性自旋锁
* 多线程竞争同步资源的流程细节有没有区别?
  * 不锁住资源,多线程中只有一个能修改资源成功,其他线程会重试
    * 无锁
  * 同一个现场执行同步资源时自动获取资源
    * 偏向锁
  * 多个线程竞争同步资源时,没有获取资源的线程自旋等待锁释放
    * 轻量级锁
  * 多个现场竞争同步资源是,没有获取资源的现场等待阻塞唤醒
    * 重量级锁
* 多个线程竞争锁时要不要排队?
  * 排队
    * 公平锁
  * 先尝试插队,插队失败再排队
    * 非公平锁
* 一个线程中的多个流程能不能获取同一把锁?
  * 能
    * 可重入锁
  * 不能
    * 非可重入锁
* 多线程能不能共享一把锁?
  * 能
    * 共享锁
  * 不能
    * 排他锁

#### 乐观锁VS悲观锁

* **理论**

  * 对于同一数据的并发操作,**悲观锁认为自己在使用数据的时候一定有别的现场来修改数据**,因此在获取数据的时候先加锁,确保数据不会被其他线程修改.

    * Java中的**synchronized**关键字和**Lock**的实现类都是悲观锁;

    ```java
    // synchronized
    public synchronized void testMethod() {
    	// 操作同步资源
    }
    
    // ReentrantLock
    private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
    public void modifyPublicResources() {
    	lock.lock();
    	// 操作同步资源
    	lock.unlock();
    }
    ```

  * **乐观锁认为自己在使用数据的时候不会有其他现场来修改数据**,所以不会添加锁,只是在更新数据的时候去判断有没有别的线程更新了这个数据.

    * 若这个数据没有被更新,当前线程将自己修改的数据成功写人;
    * 若数据已经被其他线程更新,则根据不同的实现方式执行不同的操作(如报错或者自动重试);
      * 乐观锁在Java中通过使用无锁编程来实现,最常采用的是CAS算法,Java原子类中的递增操作就通过CAS自旋实现的.

    ```java
    // 需要保证多个线程使用的是同一个AtomicInteger
    private AtomicInteger atomicInteger = new AtomicInteger(); 
    //执行自增1
    atomicInteger.incrementAndGet(); 
    ```

* **使用场景**

  * 悲观锁适合写操作多的场景,先加锁可以保证写操作时数据正确.
  * 乐观锁适合读操作多的场景,不加锁的特点能够使其读操作的性能大幅度提升;
  * 悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源;
  
* CAS

  > Compare And Swap(比较与交换),是一种无锁算法,在不适用锁(没有线程被阻塞)的情况下实现多线程之间的变量同步.java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁.
  >
  > CAS算法涉及到三个操作数:
  >
  > * 需要读写的内存值V;
  > * 进行比较的值A;
  > * 要写入的新值B;
  >
  > 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
  >
  > 之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁.
