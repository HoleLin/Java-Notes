### 锁

#### 参考文献

* [不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)

#### Java锁分类

* 线程要不要锁住同步资源?
  * 锁住
    * 悲观锁
  * 不锁住
    * 乐观锁
* 锁住同步资源失败,线程要不要阻塞?
  * 阻塞
  * 不阻塞
    * 自旋锁
    * 适应性自旋锁
* 多线程竞争同步资源的流程细节有没有区别?
  * 不锁住资源,多线程中只有一个能修改资源成功,其他线程会重试
    * 无锁
  * 同一个现场执行同步资源时自动获取资源
    * 偏向锁
  * 多个线程竞争同步资源时,没有获取资源的线程自旋等待锁释放
    * 轻量级锁
  * 多个现场竞争同步资源是,没有获取资源的现场等待阻塞唤醒
    * 重量级锁
* 多个线程竞争锁时要不要排队?
  * 排队
    * 公平锁
  * 先尝试插队,插队失败再排队
    * 非公平锁
* 一个线程中的多个流程能不能获取同一把锁?
  * 能
    * 可重入锁
  * 不能
    * 非可重入锁
* 多线程能不能共享一把锁?
  * 能
    * 共享锁
  * 不能
    * 排他锁

#### 乐观锁VS悲观锁

* **理论**

  * 对于同一数据的并发操作,**悲观锁认为自己在使用数据的时候一定有别的现场来修改数据**,因此在获取数据的时候先加锁,确保数据不会被其他线程修改.

    * Java中的**synchronized**关键字和**Lock**的实现类都是悲观锁;

    ```java
    // synchronized
    public synchronized void testMethod() {
    	// 操作同步资源
    }
    
    // ReentrantLock
    private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
    public void modifyPublicResources() {
    	lock.lock();
    	// 操作同步资源
    	lock.unlock();
    }
    ```

  * **乐观锁认为自己在使用数据的时候不会有其他现场来修改数据**,所以不会添加锁,只是在更新数据的时候去判断有没有别的线程更新了这个数据.

    * 若这个数据没有被更新,当前线程将自己修改的数据成功写人;
    * 若数据已经被其他线程更新,则根据不同的实现方式执行不同的操作(如报错或者自动重试);
      * 乐观锁在Java中通过使用无锁编程来实现,最常采用的是CAS算法,Java原子类中的递增操作就通过CAS自旋实现的.

    ```java
    // 需要保证多个线程使用的是同一个AtomicInteger
    private AtomicInteger atomicInteger = new AtomicInteger(); 
    //执行自增1
    atomicInteger.incrementAndGet(); 
    ```

* **使用场景**

  * 悲观锁适合写操作多的场景,先加锁可以保证写操作时数据正确.
  * 乐观锁适合读操作多的场景,不加锁的特点能够使其读操作的性能大幅度提升;
  * 悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源;
  
* CAS

  > Compare And Swap(比较与交换),是一种无锁算法,在不适用锁(没有线程被阻塞)的情况下实现多线程之间的变量同步.java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁.
  >
  > CAS算法涉及到三个操作数:
  >
  > * 需要读写的内存值V;
  > * 进行比较的值A;
  > * 要写入的新值B;
  >
  > 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
  >
  > 之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁.
  
  * CAS虽然很高效，但是它也存在三大问题：
  
    1. **ABA问题**
  
       。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
  
       - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
  
    2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
  
    3. **只能保证一个共享变量的原子操作.**对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
  
       - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

#### 自旋锁VS适应性自旋锁

* 理论

  > 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。
  >
  > 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。
  >
  > 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

* 自旋锁流程:

  * 不放弃CPU时间片,通过自旋等待锁释放,不停尝试获取锁,直至成功获取锁;

* 非自旋锁流程

  * ①CPU切换状态,使当前线程休眠
  * ②CPU切换线程执行其他操作
  * ③占用同步资源的线程释放了锁
  * ④回复现场
  * ⑤尝试获取锁
  * 若失败了,则重复以上操作①~⑤,直至成功获取锁

* 自旋锁的优缺点:

  * 优点:
    *  自旋锁和非自旋锁相比,自旋锁减少了CPU切换和恢复现场导致的消耗;
  * 缺点:
    * 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

  > 自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。
  >
  > 自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。
  >
  > 在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock
  >
  > * TicketLock
  >
  >   为了提供公平，有人发明了Ticket Lock
  >
  >   * 线程想要竞争某个锁，需要先领一张ticket，然后监听flag，发现flag被更新为手上的ticket的值了，才能去占领锁
  >
  >   * 就像是在医院看病一样，医生就是临界区，病人就是线程，病人挂了号领一张单子，单子上写了一个独一无二的号码，病人等的时候就看屏幕，屏幕上显示到自己的号码了，才能进去找医生。
  >   * 现在公平性的问题没有了，但是所有的线程都在监听flag变量，而且由于为了保证flag变量变化的可见性，它必须是volatile的。也就是说如果某个线程修改了flag变量，都会引起其他所有监听线程所在的core的对应于flag变量的cache line被设为invalid，那么这些线程下一次查询flag变量的时候，就必须从主存里取最新的flag数据了，由于主存带宽有限，这个开销较为昂贵（与监听线程数成正比）。
  >
  > * CLHlock
  >
  >   * 为了减少缓存一致性带来的开销，CLH Lock被发明了。CLH实际上是指三个人：Craig, Landin, and Hagersten
  >   *  CLH锁的核心思想是:
  >     * 竞争线程排队: 公平，FIFO，先来后到的顺序进入锁
  >     * 监听变量拆分: 而且没有竞争同一个变量，因为每个线程只要等待自己的前继释放就好了。
  >   * CLH锁的变种被应用于Java J.U.C包下的AbstractQueuedSynchronizer
  >
  > * MCSlock
  >
  >   * CLH锁并不是完美的，因为每个线程都是在前驱节点的locked字段上自旋，而在NUMA体系中，有可能多个线程工作在多个不同的socket上的core里。如果前驱节点的内存跟监听线程的core距离过远，会有性能问题。于是MCS锁诞生了
  > * MCS也是人名简写：John M. Mellor-Crummey and Michael L. Scott
  >   * MCS与CLH最大的不同在于：**CLH是在前驱节点的locked域上自旋，MCS是在自己节点上的locked域上自旋。**
  > * 具体的实现是，**前驱节点在释放锁之后，会主动将后继节点的locked域更新。**
  >   * 也就是把多次对远端内存的监听 + 一次对本地内存的更新，简化成了多次对本地内存的监听 + 一次对远端内存的更新。

#### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁(这四种锁是指锁的状态，专门针对synchronized的。)

* **Java对象头**

  > synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？
  >
  > 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。
  >
  > **Mark Word**：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
  >
  > **Klass Point**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

* #### Monitor

  > Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。
  >
  > Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

* synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。

* 目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。**锁状态只能升级不能降级**。





  
