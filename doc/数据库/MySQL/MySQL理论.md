### MySQL8.0理论

#### 参考文献

* [MySQL8.0官网文档](https://dev.mysql.com/doc/refman/8.0/en/preface.html)

#### MySQL介绍

> * **MySQL是一个数据库管理系统**
> * **MySQL数据库是关系型的。**
> * **MySQL软件是开源的。**
> * **MySQL数据库服务器非常快速，可靠，可扩展且易于使用。**
> * **MySQL Server可在客户端/服务器或嵌入式系统中使用。**
> * **可以使用大量的MySQL软件。**

#### 名词解释

* **关系**: 一个关系对应通常所说的一张表;
* **元组**: 表中的一行即为一个元组;
* **属性**: 表中的一列即为一个属性;每个属性都有一个名称,称为属性名;
* **候选码**: 表中的某个属性组,他可以唯一确定一个元组;
* **主码**: 一个关系有多个候选码,选定其中一个为主码;
* **域**: 属性的取值范围;
* **分量**: 元组中的一个属性值;
* **ER图**:
  * 矩形: 表示实体集,矩形内写实体集的名字;
  * 菱形: 表示联系集;
  * 椭圆: 表示实体的属性;
  * 线段: 将属性连接的实体集,或实体集连接到联系集

#### 设计范式

* 数据操作异常以及数据冗余
  * 数据操作异常
    * 插入异常:如果某实体随着另一个实体的存在而存在,即缺少某个实体时无法表示这个实体,那么这个表就存在插入异常;
    * 更新异常:如果更新表所对应的某个实体实例的单独属性时,需要将多行更新,那么就说这个表存在更新异常;
    * 删除异常:如果删除表的某一行来反映某实体实例失效是导致另一个实体实例信息丢失,那么这个表中存在删除异常;
  * 数据冗余
    * 是指相同的数据在多个地方存在,或者说表中某个列可以有其他列计算得到,这样就说表中存在数据冗余;

* **第一范式**

  * **数据库表中的所有字段都是单一属性,不可再分的;**
  * **第一范式要求数据库中的表都是二维表(行列组成)**;

* **第二范式**

  * **数据库的表中不存在非关键字对任一候选关键字段的部分函数依赖.**

    > 一、函数依赖概念
    >
    > 1、函数依赖概念：相当于数学中的函数，U是属性全集，x和y是U上的子集，x对应唯一确定的y，即x->y（y依赖于x）。
    >
    > 2、完全依赖和不完全依赖：U是属性全集，x和y是U上的子集，x1是x的真子集，如果x->y，且x1不能确定y，则是完全函数依赖，反之x1->y，则是不完全函数依赖。
    >
    > 3、传递依赖：U是属性全集，x、y和z是U上的子集，x->y(但是y不能确定x),y->z,则x->z。

    * **部分函数依赖**

      > 反例: 关系模式R（姓名，学号，班级编号，班级名），满足1NF，候选码为学号和班级编号，（学号，班级编号）->姓名，（学号，班级编号）->班级名，但是学号->姓名，班级编号->班级名，所以不是第二范式。（通过完全依赖概念得出）

      * (A,B)-->(a,b,c,d,e,f)
      * A-->(a,b,c)
      * B-->(d,e,f)

  * **所有单关键字段的表都符合第二范式;**

  * **符合1NF并且非主属性完全依赖于码。**

* **第三范式**

  * **第三范式是在第二范式的基础上定义的,如果数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式;**

    > 反例: 关系模式（姓名，学号，班级，班主任），满足2NF，，主键是学号，但是学号->班级，班级->班主任，得出学号->班主任，所以不是第三范式。（通过传递依赖概念得出）

    * A-->B-->C

  * **符合2NF并且消除传递依赖**

* **BC范式**

  * **在第三范式的基础上,数据库表中如果不存在任何字段对任意候选关键字段的传递函数依赖则符合BC范式,也就是说如果是复合关键字,则复合关键字之间也不能存在函数依赖关系**
  * **BC范式（BCNF）：符合3NF并且主属性不依赖于主属性**
  * **若关系模式属于第一范式，且每个属性都不传递依赖于键码，则R属于BC范式。**
  * 通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。还可以这么说：**若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式**。

#### MySQL常用存储引擎

| 存储引擎    | 事务   | 锁粒度               | 主要应用                   | 忌用                         |
| ----------- | ------ | -------------------- | -------------------------- | ---------------------------- |
| MyISAM      | 不支持 | 支持并发插入的表级锁 | SELECT,INSERT              | 读写操作频繁                 |
| MRG_MYISAM  | 不支持 | 支持并发插入的表级锁 | 分段归档,数据仓库          | 全局查找过多的场景           |
| Innodb      | 支持   | 支持MVCC的行级锁     | 事务处理                   | 无                           |
| Archive     | 不支持 | 行级锁               | 日志记录,支持INSERT,SELECT | 需要随机读取,更新,删除的场景 |
| Ndb cluster | 支持   | 行级锁               | 高可用                     |                              |

#### 表及字段命名规则

* 可读性原则: 使用大写和小写来格式化的库对象名字以获取良好的可读性

* 表意性原则: 对象的名字应该能描述它所标识的对象;

  * 对于表,表的名称应该能体现出表中存储的数据的内容;
  * 对于存储过程,存储过程的名称一个能体现出存储过程的功能;
  
* 长名原则: 尽可能少使用或者不适用缩写,适用于数据库(DATABASE)名之外的任一对象;
#### 字段类型选择原则

> 列的数据类型一方面影响数据存储空间的开销,另一方面也会影响数据查询性能.
>
> * 当一个列可以选择多种数据类型时,应该优先考虑数字类型,其次是日期类型或者二进制类型,最后是字符类型
> * 对于相同级别的数据,应该优先选择占用空间小的数据类型

* 常用字段类型以及占用空间

  | 字段类型   | 占用空间               |
  | ---------- | ---------------------- |
  | TINYINT    | 1字节                  |
  | SMALLINT   | 2字节                  |
  | MEDIUMINT  | 3字节                  |
  | INT        | 4字节                  |
  | BINGINT    | 8字节                  |
  | DATE       | 3字节                  |
  | DATETIME   | 8字节                  |
  | TIMESTAMP  | 4字节(~2037年)         |
  | CHAR(M)    | M字节,1<=M<=255        |
  | VARCHAR(M) | L+1字节,L<=M,1<=M<=255 |

  * 在对数据进行比较(查询条件,Join条件以及排序)操作时,**同样的数据,字符串往往比数字处理慢;**
  * 在数据库中,数据处理以页为单位,列的长度越小,利于性能提升;

* char与varchar如何选择?

  * 如果列中要存储的数据长度差不多是一致的,应该考虑用char,否则应该考虑用varchar;
  * 如果列中最大的数据长度小于50Byte,则一般考虑用char,若这个列很少用,则基于节省空间和减少I/O的考虑,还可以使用varchar;
  * 一般不宜定义大于50Byte的char类型;
  * 一旦指定类型为char,字符串长度不够指定长度的时候,则会补充空格,超过则会存储指定长度的字符串(在非严格模式下);
  * varchar:默认会在最后增加一个字符长度,占用一个字节

  