### 数据库面试题

* **参考文献**
  * [分布式系统架构面试题汇总（万字总结）](https://zhuanlan.zhihu.com/p/267712773)

#### 主从复制

* 主从复制一般采用多主多从的方案

##### 多主条件下数据一致性问题

* **描述**

  > 也就是两台主数据库同时更新了数据，以谁的为主

* **解决方案**

  * **根据时间戳进行判断**
    * 最后写入的，也就是时间戳在后面的，覆盖时间戳在前面的。
  * **通过投票进行解决**。

##### **主节点挂掉了怎么办？**

* **解决方案**

  > 多主多从模式中，几台主服务器相互监督观察，只要对面的有更新自己也更新；

#### 分库分表

* **垂直分库分表**

  > 垂直分表意味着对这个表大部分增删改查的操作需要跨库，系统开销太大，一般不使用。垂直分库也会带来事务等问题，解决办法是Rpc

* **水平分库分表**

  * **根据数值范围**
    * 按照时间区间或ID区间来切分。例如：将userId为1~9999的记录分到第一个库，10000~20000的分到第二个库，以此类推。
    * **优点**:
      * 单表大小可控;
      * 天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移;
      * 使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。
    * **缺点**:
      * 热点数据可能较为集中，造成压力。
  * **根据数据取模**
    * 例如：将 Customer 表根据 no字段切分到4个库中，余数为0的放到第一个库，余数为1的放到第二个库，以此类推。
    * **优点**:
      * 数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈
    * **缺点**:
      * 扩容比较麻烦，新增加一个数据库时，需要重新hash

* **分库分表出现的问题**

  * **事务一致性问题(垂直分库问题)**
    * **解决分案**
      * **分布式事务**
        *  当更新内容同时分布在不同库中，垂直分库，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用"XA协议"和"两阶段提交"处理。
      * **最终一致性**
        * 只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。也就是基于日志，进行同步；
    
  * **跨节点关联查询 join 问题（垂直分库问题）**
    * **解决方案**
      * **全局表**
        * 全局表，也可看做是"数据字典表"，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。
      * **字段冗余**
        * 在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。
      * **ER分片**
        * 关系型数据库中，如果可以先确定表之间的关联关系，并将那些存在关联关系的表记录存放在同一个分片上
    
  * **跨节点分页、排序、函数问题（水平分库问题）**

    * **分页问题**

      > 需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。

    * **函数问题**

      > 在使用Max、Min、Sum、Count之类的函数进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。

  * **分布式ID问题**

    * **描述**

      > 在分库分表的环境中，数据分布在不同的分片上，不能再借助数据库自增长特性直接生成，否则会造成不同分片上的数据表主键会重复。简单介绍下使用和了解过的几种 ID 生成算法。

    * **分布式ID定义**

      * 基本的要求包括：
        * 全局唯一，区别于单点系统的唯一，全局是要求分布式系统内唯一。
        * 有序性，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。

    * **解决方案**

      * **Twitter 的 Snowflake（又名“雪花算法”）**

        > 这种方案把64-bit分别划分成多段，分开来标示机器、时间等
        >
        > snowflake-64-bit
        >
        > ​										41-bit时间戳	  								10bit-workerId   10bit-序列号	
        >
        > ​	|---------------------------------------------------------------------------|  |--------------|  |------------------|		
        >
        > **0** - 00000000 00000000 00000000 00000000 00000000 0 - 0000000 00 - 0000000 0000
        >
        > * 头部是 1 位的正负标识位。
        >
        > * 紧跟着的高位部分包含 41 位时间戳，通常使用 System.currentTimeMillis()。
        >
        > * 后面是 10 位的 WorkerID，标准定义是 5 位数据中心 + 5 位机器 ID，组成了机器编号，以区分不同的集群节点。
        >
        > * 最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。
        >
        > 这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。

        * Java实现

        ```java
        /**
         * From https://github.com/relops/snowflake
         * A snowflake is a source of k-ordered unique 64-bit integers.
         */
        public class Snowflake {
        
          public static final int NODE_SHIFT = 10;
          public static final int SEQ_SHIFT = 12;
        
          public static final short MAX_NODE = 1024;
          public static final short MAX_SEQUENCE = 4096;
        
          private short sequence;
          private long referenceTime;
        
          private int node;
        
          /**
           * A snowflake is designed to operate as a singleton instance within the context of a node.
           * If you deploy different nodes, supplying a unique node id will guarantee the uniqueness
           * of ids generated concurrently on different nodes.
           *
           * @param node This is an id you use to differentiate different nodes.
           */
          public Snowflake(int node) {
            if (node < 0 || node > MAX_NODE) {
              throw new IllegalArgumentException(String.format("node must be between %s and %s", 0, MAX_NODE));
            }
            this.node = node;
          }
        
          /**
           * Generates a k-ordered unique 64-bit integer. Subsequent invocations of this method will produce
           * increasing integer values.
           *
           * @return The next 64-bit integer.
           */
          public long next() {
        
            long currentTime = System.currentTimeMillis();
            long counter;
        
            synchronized(this) {
        
              if (currentTime < referenceTime) {
                throw new RuntimeException(String.format("Last referenceTime %s is after reference time %s", referenceTime, currentTime));
              } else if (currentTime > referenceTime) {
                this.sequence = 0;
              } else {
                if (this.sequence < Snowflake.MAX_SEQUENCE) {
                  this.sequence++;
                } else {
                  throw new RuntimeException("Sequence exhausted at " + this.sequence);
                }
              }
              counter = this.sequence;
              referenceTime = currentTime;
            }
        
            return currentTime << NODE_SHIFT << SEQ_SHIFT | node << SEQ_SHIFT | counter;
          }
        
        }
        ```

        * [百度](https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md)
        * 美团
          * [博客](https://tech.meituan.com/2017/04/21/mt-leaf.html)
          * [Github](https://github.com/Meituan-Dianping/Leaf)
        * 滴滴
          * [Github](https://github.com/didi/tinyid)

    * **利用Zookeeper生成唯一ID**

      > Zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。

    * **Redis生成ID**

      > 这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。

    ​    

    ​    

